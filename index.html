<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å®‰å…¨å‘ç¥¨åŠ©æ‰‹ v1.12.1</title>
    
    <!-- 1. å…¨å±€é”™è¯¯æ•æ‰ -->
    <script>
        window.onerror = function(msg, url, line, col, error) {
            var errorMsg = "ç¨‹åºå¯åŠ¨å¼‚å¸¸ï¼š\n" + msg + "\nè¡Œå·ï¼š" + line;
            if(msg.indexOf('ResizeObserver') === -1) {
                document.getElementById('loading-text').innerText = "âš ï¸ ç¨‹åºåŠ è½½å‡ºé”™ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°";
                document.getElementById('loading-text').style.color = "red";
                alert(errorMsg);
            }
        };
    </script>

    <!-- 2. æ ¸å¿ƒä¾èµ– -->
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- 3. å¤‡ç”¨ CDN åŠ è½½é€»è¾‘ -->
    <script>
        function loadScript(url) {
            document.write('<script src="' + url + '"><\/script>');
        }
        if (typeof Vue === 'undefined') loadScript('https://unpkg.zhimg.com/vue@3.3.4/dist/vue.global.prod.js');
        if (typeof PDFLib === 'undefined') loadScript('https://unpkg.zhimg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js');
        if (typeof pdfjsLib === 'undefined') loadScript('https://unpkg.zhimg.com/pdfjs-dist@2.16.105/build/pdf.min.js');
        if (typeof JSZip === 'undefined') loadScript('https://unpkg.zhimg.com/jszip@3.10.1/dist/jszip.min.js');
    </script>

    <style>
        :root {
            --primary-color: #1677ff;
            --primary-hover: #4096ff;
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --text-main: #333333;
            --text-sub: #666666;
            --text-light: #999999;
            --border-color: #d9d9d9;
            --error-color: #ff4d4f;
            --success-color: #52c41a;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0;
            padding: 0;
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            width: 100%;
            max-width: 700px; 
            margin: 0 auto;
            padding: 40px 20px;
            flex: 1;
        }

        /* å¯åŠ¨åŠ è½½å±‚ */
        #app-loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 9999; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
        }
        [v-cloak] + #app-loading { display: block; }
        #app:not([v-cloak]) ~ #app-loading { display: none; }

        header { text-align: center; margin-bottom: 30px; }
        
        h1 { 
            color: var(--text-main); 
            font-size: 32px; 
            margin: 0 0 10px 0; 
            font-weight: 700; 
            letter-spacing: -0.5px;
        }
        
        .version { 
            font-size: 13px; 
            font-weight: normal;
            color: var(--text-sub); 
            background: #e6e6e6; 
            padding: 2px 8px; 
            border-radius: 10px; 
            vertical-align: middle; 
            margin-left: 10px; 
        }
        
        .subtitle { color: var(--text-sub); font-size: 14px; line-height: 1.5; max-width: 600px; margin: 0 auto; }

        .card {
            background: var(--card-bg);
            border-radius: 16px; 
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            padding: 24px;
            margin-bottom: 24px;
            transition: all 0.3s ease;
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #fafafa;
        }

        .upload-area:hover, .upload-area.drag-active {
            border-color: var(--primary-color);
            background-color: #f0f7ff;
        }

        .upload-icon { font-size: 48px; color: var(--primary-color); margin-bottom: 16px; }
        .upload-text { font-size: 16px; color: var(--text-main); margin-bottom: 8px; font-weight: 500; }
        .upload-hint { font-size: 12px; color: var(--text-light); }

        .file-list { list-style: none; padding: 0; margin: 0; }
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }
        .file-item:last-child { border-bottom: none; }
        
        .file-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            overflow: hidden;
            min-width: 0;
        }

        .file-icon { font-size: 20px; flex-shrink: 0; }
        
        .file-name {
            font-size: 14px;
            color: var(--text-main);
            flex: 1;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2;
            overflow: hidden;
            word-break: break-all;
            line-height: 1.4;
        }
        
        .file-tag {
            font-size: 10px;
            padding: 1px 5px;
            border-radius: 3px;
            margin-left: 6px;
            white-space: nowrap;
            flex-shrink: 0;
            display: inline-block;
            vertical-align: middle;
        }
        .tag-full { background-color: #e6f4ff; color: #1677ff; border: 1px solid #91caff; }
        .tag-img { background-color: #f9f0ff; color: #722ed1; border: 1px solid #d3adf7; }

        .file-status {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            flex-shrink: 0;
            margin-left: 8px;
        }
        .status-loading { color: var(--primary-color); background-color: #e6f7ff; }
        .status-success { background-color: #f6ffed; color: var(--success-color); }
        .status-error { background-color: #fff2f0; color: var(--error-color); }

        .action-group {
            display: flex;
            align-items: center;
            gap: 2px;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .icon-btn {
            cursor: pointer;
            color: var(--text-light);
            padding: 8px;
            border-radius: 4px;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn:hover { background-color: #f5f5f5; color: var(--primary-color); }
        .icon-btn.delete:hover { color: var(--error-color); background-color: #fff1f0; }
        .icon-btn:disabled, .icon-btn.disabled { color: #e0e0e0; cursor: default; pointer-events: none; }

        .settings-box {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fafafa;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 14px;
            color: var(--text-main);
        }
        .settings-title { font-weight: 600; color: var(--text-main); flex-shrink: 0; }
        .radio-group { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .radio-label { display: flex; align-items: center; gap: 6px; cursor: pointer; color: var(--text-sub); }
        .radio-label input { cursor: pointer; }

        .btn-group { display: flex; gap: 12px; flex-wrap: wrap; }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 14px 20px;
            font-size: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 200px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover { background-color: var(--primary-hover); }
        .btn:disabled { background-color: #d9d9d9; border-color: #d9d9d9; color: #fff; cursor: not-allowed; }

        .btn-outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        .btn-outline:hover {
            background-color: #f0f7ff;
            color: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        footer { text-align: center; padding: 20px 0; margin-top: auto; }
        .footer-info { font-size: 12px; color: var(--text-light); line-height: 1.6; }

        .spinner {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }
        .btn .spinner { border-color: rgba(255,255,255,0.6); border-right-color: transparent; }
        
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="app-loading">
    <div style="font-size: 24px; margin-bottom: 10px;">â³</div>
    <div id="loading-text" style="color: #666; font-size: 14px;">æ­£åœ¨åˆå§‹åŒ–ç»„ä»¶...<br>é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</div>
</div>

<!-- ä¿®å¤ç‚¹ï¼šæ·»åŠ  class="container" -->
<div id="app" class="container">
    <header>
        <h1>å®‰å…¨å‘ç¥¨åŠ©æ‰‹<span class="version">v1.12.1</span></h1>
        <div class="subtitle">å°†å¤šä¸ªå•é¡µçš„å‘ç¥¨æ–‡ä»¶æ‹¼æˆå•ä¸ª A4 ç«–ç‰ˆ PDFï¼Œä¾¿äºæ‰“å°ç•™æ¡£<br>æ”¯æŒè‡ªåŠ¨è¯†åˆ«å‘ç¥¨ä¿¡æ¯å¹¶é‡å‘½åæˆ–å¯¼å‡ºæ–‡æœ¬æ–‡ä»¶</div>
    </header>

    <div class="card">
        <div 
            class="upload-area" 
            :class="{ 'drag-active': isDragging }"
            @dragover.prevent="isDragging = true"
            @dragleave.prevent="isDragging = false"
            @drop.prevent="handleDrop"
            @click="triggerFileInput"
        >
            <div class="upload-icon">
                <svg viewBox="0 0 1024 1024" width="48" height="48" fill="currentColor"><path d="M544 269.4v304.2c0 8.8-7.2 16-16 16h-32c-8.8 0-16-7.2-16-16V269.4L372.6 376.8c-6.2 6.3-16.4 6.3-22.6 0l-22.6-22.6c-6.3-6.3-6.3-16.4 0-22.6l166.6-166.7c6.3-6.3 16.4-6.3 22.6 0l166.6 166.7c6.3 6.3 6.3 16.4 0 22.6l-22.6 22.6c-6.2 6.3-16.4 6.3-22.6 0L544 269.4zM832 768H192c-17.7 0-32 14.3-32 32v32c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32v-32c0-17.7-14.3-32-32-32z" /></svg>
            </div>
            <div class="upload-text">ç‚¹å‡»æ‰“å¼€æˆ–æ‹–æ‹½å‘ç¥¨/å›¾ç‰‡åˆ°è¿™é‡Œ</div>
            <div class="upload-hint">æ¨ªç‰ˆä¸Šä¸‹æ‹¼å›¾ï¼Œç«–ç‰ˆè‡ªåŠ¨å•é¡µï¼Œå›¾ç‰‡è‡ªåŠ¨æ—‹è½¬ï¼Œæ”¯æŒ PDF/JPG/PNG</div>
            <input type="file" ref="fileInput" multiple accept="application/pdf,image/jpeg,image/png" style="display: none" @change="handleFileSelect">
        </div>
    </div>

    <div class="card" v-if="files.length > 0">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
            <h3 style="margin: 0; font-size: 16px;">æ–‡ä»¶åˆ—è¡¨ ({{ files.length }})</h3>
            <span style="font-size:12px; color:var(--primary-color); cursor:pointer;" @click="clearAll">æ¸…ç©ºåˆ—è¡¨</span>
        </div>
        
        <ul class="file-list">
            <li v-for="(file, index) in files" :key="file.id" class="file-item">
                <div class="file-info">
                    <span class="file-icon">{{ getFileIcon(file.type) }}</span>
                    <div class="file-name">
                        {{ file.name }}
                        <span v-if="file.isPortraitPdf" class="file-tag tag-full">ç«–ç‰ˆæ•´é¡µ</span>
                        <span v-if="file.isImage && file.isPortrait" class="file-tag tag-img">è‡ªåŠ¨æ—‹è½¬</span>
                        <span v-if="file.isHSR" class="file-tag" style="background:#fff7e6;color:#fa8c16;border:1px solid #ffd591">é«˜é“ç¥¨</span>
                    </div>
                    
                    <span v-if="file.isChecking" class="file-status status-loading">è§£æ</span>
                    <span v-else-if="file.isValid" class="file-status status-success">å°±ç»ª</span>
                    <span v-else class="file-status status-error">âŒ {{ file.errorMsg }}</span>
                </div>
                
                <div class="action-group">
                    <div class="icon-btn" :class="{ disabled: index === 0 }" @click="moveFile(index, -1)" title="ä¸Šç§»">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z"/></svg>
                    </div>
                    <div class="icon-btn" :class="{ disabled: index === files.length - 1 }" @click="moveFile(index, 1)" title="ä¸‹ç§»">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"/></svg>
                    </div>
                    <div class="icon-btn delete" @click="removeFile(index)" title="åˆ é™¤">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"/></svg>
                    </div>
                </div>
            </li>
        </ul>
    </div>

    <div v-if="files.length > 0">
        <div class="settings-box">
            <span class="settings-title">é¡µé¢è¾¹è·ï¼š</span>
            <div class="radio-group">
                <label class="radio-label">
                    <input type="radio" v-model="paddingSetting" :value="15">
                    é»˜è®¤è¾¹è·ï¼ˆçº¦ 5mmï¼‰
                </label>
                <label class="radio-label">
                    <input type="radio" v-model="paddingSetting" :value="30">
                    2 å€è¾¹è·ï¼ˆé€‚åˆæ—§æ‰“å°æœºæˆ–è£…è®¢ä½¿ç”¨ï¼‰
                </label>
            </div>
        </div>

        <div class="btn-group">
            <button class="btn btn-outline" @click="renameAndZip" :disabled="currentAction !== 'idle'">
                <span v-if="currentAction === 'rename'" class="spinner"></span>
                {{ currentAction === 'rename' ? 'å¤„ç†ä¸­...' : 'æ ¹æ®å†…å®¹é‡å‘½åå‘ç¥¨' }}
            </button>
            <button class="btn btn-outline" @click="exportToTxt" :disabled="currentAction !== 'idle'">
                <span v-if="currentAction === 'export'" class="spinner"></span>
                {{ currentAction === 'export' ? 'å¤„ç†ä¸­...' : 'è¯†åˆ«å¹¶å¯¼å‡ºå‘ç¥¨ä¿¡æ¯' }}
            </button>
            <button class="btn" @click="processAndDownload" :disabled="currentAction !== 'idle' || validFilesCount === 0">
                <span v-if="currentAction === 'merge'" class="spinner"></span>
                {{ currentAction === 'merge' ? 'å¤„ç†ä¸­...' : 'ç”Ÿæˆåˆå¹¶ PDF' }}
            </button>
        </div>
        
        <p style="text-align: center; font-size: 12px; color: var(--text-sub); margin-top: 12px;">
            <span v-if="validFilesCount > 0">
                é¢„è®¡ç”Ÿæˆæ–‡ä»¶é¡µæ•°ï¼š{{ estimatedPages }} é¡µ
            </span>
        </p>
    </div>

    <footer>
        <div class="footer-info">
            çº¯æœ¬åœ°å¤„ç† Â· éšç§å®‰å…¨ Â· Design by Walter
        </div>
    </footer>
</div>

<script>
    const { createApp, ref, computed, onMounted } = Vue;
    // å®‰å…¨è·å–å…¨å±€å˜é‡
    const PDFLib = window.PDFLib || {};
    const { PDFDocument, rgb, degrees, grayscale } = PDFLib;

    // é…ç½® PDF.js worker (ä½¿ç”¨ v2.16 ç‰ˆæœ¬çš„ worker)ã€‚æœ¬ç¨‹åºäº2025å¹´12æœˆ30æ—¥ç”±ZYCåˆ¶ä½œå®Œæˆã€‚
    if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.bootcdn.net/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }

    createApp({
        setup() {
            const files = ref([]);
            const isDragging = ref(false);
            const currentAction = ref('idle');
            const fileInput = ref(null);
            const paddingSetting = ref(15);
            let fileIdCounter = 0; 

            // æŒ‚è½½å®Œæˆåï¼Œéšè— loading é®ç½©
            onMounted(() => {
                const loader = document.getElementById('app-loading');
                if(loader) loader.style.display = 'none';
            });

            const validFilesCount = computed(() => files.value.filter(f => f.isValid).length);

            const btnText = computed(() => {
                if (currentAction.value === 'merge') return 'å¤„ç†ä¸­...';
                if (validFilesCount.value === 0) return 'è¯·å…ˆæ·»åŠ æ–‡ä»¶';
                return 'ç”Ÿæˆåˆå¹¶ PDF';
            });

            const estimatedPages = computed(() => {
                let pageCount = 0;
                let pendingHalf = false;
                const validFiles = files.value.filter(f => f.isValid);

                for (const file of validFiles) {
                    if (file.type === 'pdf' && file.isPortraitPdf) {
                        if (pendingHalf) { pageCount++; pendingHalf = false; }
                        pageCount++;
                    } else {
                        if (pendingHalf) { pageCount++; pendingHalf = false; }
                        else { pendingHalf = true; }
                    }
                }
                if (pendingHalf) pageCount++;
                return pageCount;
            });

            const getFileIcon = (type) => {
                if (type === 'pdf') return 'ğŸ“„';
                if (type === 'image') return 'ğŸ–¼ï¸';
                return 'ğŸ“ƒ';
            };

            const triggerFileInput = () => fileInput.value.click();

            const handleFileSelect = (event) => {
                addFiles(event.target.files);
                event.target.value = '';
            };

            const handleDrop = (event) => {
                isDragging.value = false;
                addFiles(event.dataTransfer.files);
            };

            const addFiles = async (fileList) => {
                for (let i = 0; i < fileList.length; i++) {
                    const file = fileList[i];
                    if (file.type !== 'application/pdf' && file.type !== 'image/jpeg' && file.type !== 'image/png') {
                        continue;
                    }
                    
                    const newFile = {
                        id: fileIdCounter++,
                        name: file.name,
                        fileData: file,
                        type: file.type === 'application/pdf' ? 'pdf' : 'image',
                        isChecking: true,
                        isValid: false,
                        isImage: file.type.startsWith('image/'),
                        isPortrait: false,
                        isPortraitPdf: false,
                        errorMsg: '',
                        arrayBuffer: null,
                        invoiceNum: '', 
                        amount: '',
                        sellerName: '',
                        itemName: '',
                        isHSR: false
                    };
                    files.value.push(newFile);
                    checkFile(files.value[files.value.length - 1]);
                }
            };

            const checkFile = async (fileItem) => {
                try {
                    const buffer = await fileItem.fileData.arrayBuffer();
                    fileItem.arrayBuffer = buffer;

                    if (fileItem.type === 'pdf') {
                        const pdfDoc = await PDFDocument.load(buffer, { ignoreEncryption: true });
                        const pageCount = pdfDoc.getPageCount();
                        if (pageCount === 1) {
                            fileItem.isValid = true;
                            const page = pdfDoc.getPages()[0];
                            const { width, height } = page.getSize();
                            const rotation = page.getRotation().angle;
                            const isRotated = rotation % 180 !== 0;
                            const visualWidth = isRotated ? height : width;
                            const visualHeight = isRotated ? width : height;

                            if (visualHeight > visualWidth) {
                                fileItem.isPortraitPdf = true;
                            }
                            
                            extractInvoiceInfo(fileItem, buffer.slice(0));
                        } else {
                            fileItem.isValid = false;
                            fileItem.errorMsg = `${pageCount}é¡µPDF(ä»…æ”¯æŒå•é¡µ)`;
                        }
                    } else if (fileItem.type === 'image') {
                        await checkImageDimensions(fileItem, buffer);
                        fileItem.isValid = true;
                    }
                } catch (e) {
                    console.error('æ–‡ä»¶é”™è¯¯:', e);
                    fileItem.isValid = false;
                    fileItem.errorMsg = 'æ–‡ä»¶æŸå';
                } finally {
                    fileItem.isChecking = false;
                }
            };

            const extractInvoiceInfo = async (fileItem, bufferCopy) => {
                if (!window.pdfjsLib) return; 

                try {
                    const loadingTask = pdfjsLib.getDocument({ data: bufferCopy });
                    const pdf = await loadingTask.promise;
                    const page = await pdf.getPage(1);
                    const textContent = await page.getTextContent();
                    
                    const items = textContent.items;
                    items.sort((a, b) => {
                        const yDiff = b.transform[5] - a.transform[5];
                        if (Math.abs(yDiff) > 5) return yDiff; 
                        return a.transform[4] - b.transform[4];
                    });

                    const lines = [];
                    let currentLine = { y: -1, text: '', items: [] };
                    for (const item of items) {
                        const y = item.transform[5];
                        if (Math.abs(y - currentLine.y) > 5) {
                            if (currentLine.y !== -1) lines.push(currentLine);
                            currentLine = { y: y, text: item.str, items: [item] };
                        } else {
                            currentLine.text += ' ' + item.str;
                            currentLine.items.push(item);
                        }
                    }
                    if (currentLine.y !== -1) lines.push(currentLine);

                    const clean = (s) => s.replace(/\s+/g, '');
                    const fullText = lines.map(l => l.text).join('\n'); 
                    const cleanFullText = clean(fullText);

                    // 1. é«˜é“ç¥¨åˆ¤æ–­
                    const hasInvoiceLabel = /å‘ç¥¨å·ç |No\.|No:|å·ç /i.test(cleanFullText);
                    const hasTrainNum = /[A-Z]\d{1,4}/.test(cleanFullText);
                    const hasIDMask = /\d+\*{4,}[0-9X]+/i.test(cleanFullText);

                    if (!hasInvoiceLabel && (hasTrainNum || hasIDMask)) {
                        fileItem.isHSR = true;
                        fileItem.sellerName = "12306";
                        fileItem.itemName = "é“è·¯ç”µå­å®¢ç¥¨";

                        const hsrNumMatch = cleanFullText.match(/(\d{20})/);
                        if (hsrNumMatch) fileItem.invoiceNum = hsrNumMatch[1];

                        for (const line of lines) {
                            const txt = clean(line.text);
                            const match = txt.match(/^[:ï¼š]?(\d+\.\d{2})$/);
                            if (match) fileItem.amount = match[1];
                        }
                    } else {
                        // 2. æ™®é€šå‘ç¥¨
                        const numRegex = /(?:å‘ç¥¨å·ç |No\.?|NO\.?|å·ç )[^\d]{0,5}(\d{8,20})/i;
                        const numMatch = cleanFullText.match(numRegex);
                        if (numMatch) fileItem.invoiceNum = numMatch[1];

                        const regexSymbol = /[Â¥ï¿¥]([0-9,\.]+\d{2})/g;
                        const regexKeyword = /(?:é‡‘é¢|ç¥¨ä»·|ä»·ç¨åˆè®¡)[^\d]{0,5}([0-9,\.]+\d{2})/g;
                        const allMatches = [];
                        const collect = (regex, text) => {
                            let match;
                            while ((match = regex.exec(text)) !== null) { allMatches.push(match[1]); }
                        };
                        collect(regexSymbol, cleanFullText);
                        collect(regexKeyword, cleanFullText);

                        if (allMatches.length > 0) {
                            fileItem.amount = allMatches[allMatches.length - 1].replace(/,/g, '');
                        }

                        for (const line of lines) {
                            const txt = clean(line.text);
                            if (txt.includes("é”€") && txt.includes("åç§°")) {
                                const sellerPart = txt.substring(txt.indexOf("é”€"));
                                const sellerMatch = sellerPart.match(/åç§°[:ï¼š]?([^ ]+)/);
                                if (sellerMatch) { fileItem.sellerName = sellerMatch[1]; break; }
                            }
                        }

                        let headerIndex = -1;
                        for (let i = 0; i < lines.length; i++) {
                            const txt = clean(lines[i].text);
                            if (txt.includes("é¡¹ç›®åç§°") || txt.includes("è´§ç‰©æˆ–åº”ç¨åŠ³åŠ¡")) { headerIndex = i; break; }
                        }
                        if (headerIndex !== -1 && lines[headerIndex + 1]) {
                            const nextLineText = lines[headerIndex + 1].text.trim();
                            const parts = nextLineText.split(/\s+/);
                            if (parts.length > 0) fileItem.itemName = parts[0];
                        }
                    }
                } catch (e) {
                    console.warn("æ–‡å­—æå–å¤±è´¥", e);
                }
            };

            const checkImageDimensions = (fileItem, buffer) => {
                return new Promise((resolve) => {
                    const blob = new Blob([buffer]);
                    const img = new Image();
                    img.onload = () => {
                        if (img.height > img.width) fileItem.isPortrait = true;
                        URL.revokeObjectURL(img.src);
                        resolve();
                    };
                    img.src = URL.createObjectURL(blob);
                });
            };

            const removeFile = (index) => files.value.splice(index, 1);
            const clearAll = () => files.value = [];
            const moveFile = (index, direction) => {
                const newIndex = index + direction;
                if (newIndex >= 0 && newIndex < files.value.length) {
                    const temp = files.value[index];
                    files.value[index] = files.value[newIndex];
                    files.value[newIndex] = temp;
                }
            };

            // é‡å‘½åå¹¶æ‰“åŒ…
            const renameAndZip = async () => {
                if (validFilesCount.value === 0) {
                    alert('åˆ—è¡¨ä¸ºç©ºï¼Œæ— æ³•å¤„ç†');
                    return;
                }
                if (!window.JSZip) {
                    alert('JSZip ç»„ä»¶æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
                    return;
                }

                currentAction.value = 'rename';
                await new Promise(r => setTimeout(r, 100)); // è®©UIæ¸²æŸ“ loading

                try {
                    const zip = new JSZip();
                    const usedNames = new Set();

                    const clean = (str) => {
                        if (!str) return '';
                        return str.replace(/[\/\\:*?"<>| \s]/g, '');
                    };

                    files.value.forEach((file, index) => {
                        if (!file.isValid) return;

                        let extension = file.name.substring(file.name.lastIndexOf('.'));
                        let baseName = file.name.substring(0, file.name.lastIndexOf('.'));
                        let newName = "";

                        // æ¡ä»¶ï¼šå¿…é¡»æ˜¯ PDF ä¸”æå–åˆ°äº†å…³é”®ä¿¡æ¯
                        const isExtracted = (file.type === 'pdf') && (file.invoiceNum || file.amount || file.isHSR);

                        if (isExtracted) {
                            let seller = clean(file.sellerName) || 'æœªçŸ¥é”€å”®æ–¹';
                            let item = clean(file.itemName) || 'æœªçŸ¥é¡¹ç›®';
                            let amount = clean(file.amount) ? `Â¥${clean(file.amount)}` : '0.00';
                            let num = clean(file.invoiceNum) || `æœªçŸ¥å·ç `;
                            
                            newName = `${seller}-${item}-${amount}-${num}${extension}`;
                        } else {
                            // å¤±è´¥å›é€€ç­–ç•¥ï¼šåŸå(åŸå).pdf
                            newName = `${baseName}(åŸå)${extension}`;
                        }

                        if (usedNames.has(newName)) {
                            let counter = 1;
                            let tempName = newName;
                            while(usedNames.has(tempName)) {
                                let namePart = newName.substring(0, newName.lastIndexOf('.'));
                                tempName = `${namePart}_(${counter})${extension}`;
                                counter++;
                            }
                            newName = tempName;
                        }
                        usedNames.add(newName);
                        zip.file(newName, file.fileData);
                    });

                    const content = await zip.generateAsync({type:"blob"});
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(content);
                    link.download = `å‘ç¥¨å½’æ¡£_${formatDate(new Date())}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                } catch(e) {
                    alert('æ‰“åŒ…å¤±è´¥ï¼š' + e.message);
                } finally {
                    currentAction.value = 'idle';
                }
            };

            const exportToTxt = async () => {
                if (validFilesCount.value === 0) return;
                currentAction.value = 'export';
                await new Promise(r => setTimeout(r, 200));

                try {
                    let txtContent = "\uFEFFå‘ç¥¨æ‰¹é‡è¯†åˆ«ç»“æœå¦‚ä¸‹ã€å‘ç¥¨å·ç ã€‘-ã€å‘ç¥¨é‡‘é¢ã€‘-ã€é”€å”®æ–¹åç§°ã€‘-ã€é¡¹ç›®åç§°ã€‘\n";
                    files.value.forEach(file => {
                        if (file.isValid) {
                            const numStr = file.invoiceNum || "-";
                            const amountVal = file.amount ? `Â¥ ${file.amount}` : "-";
                            const sellerStr = file.sellerName || "-";
                            const itemStr = file.itemName || "-";
                            txtContent += `${numStr} - ${amountVal} - ${sellerStr} - ${itemStr}\n`;
                        }
                    });
                    const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8;' });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = `å‘ç¥¨ä¿¡æ¯_${formatDate(new Date())}.txt`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } finally {
                    currentAction.value = 'idle';
                }
            };

            const processAndDownload = async () => {
                if (validFilesCount.value === 0) return;
                currentAction.value = 'merge';
                await new Promise(r => setTimeout(r, 50)); 

                try {
                    const mergedPdf = await PDFDocument.create();
                    const validFiles = files.value.filter(f => f.isValid);
                    let pendingHalfPageFile = null;
                    const padding = paddingSetting.value; 

                    for (let i = 0; i < validFiles.length; i++) {
                        await new Promise(r => setTimeout(r, 0)); // é˜²å¡æ­»
                        const file = validFiles[i];

                        if (file.type === 'pdf' && file.isPortraitPdf) {
                            if (pendingHalfPageFile) {
                                const page = mergedPdf.addPage();
                                const { width, height } = page.getSize();
                                drawCutLine(page, width, height);
                                await embedAndDraw(mergedPdf, page, pendingHalfPageFile, 0, height/2, width, height/2, padding);
                                pendingHalfPageFile = null;
                            }
                            const fullPage = mergedPdf.addPage();
                            const { width, height } = fullPage.getSize();
                            await embedAndDraw(mergedPdf, fullPage, file, 0, 0, width, height, padding);
                        } else {
                            if (pendingHalfPageFile) {
                                const page = mergedPdf.addPage();
                                const { width, height } = page.getSize();
                                drawCutLine(page, width, height);
                                await embedAndDraw(mergedPdf, page, pendingHalfPageFile, 0, height/2, width, height/2, padding);
                                await embedAndDraw(mergedPdf, page, file, 0, 0, width, height/2, padding);
                                pendingHalfPageFile = null;
                            } else {
                                pendingHalfPageFile = file;
                            }
                        }
                    }

                    if (pendingHalfPageFile) {
                        const page = mergedPdf.addPage();
                        const { width, height } = page.getSize();
                        drawCutLine(page, width, height);
                        await embedAndDraw(mergedPdf, page, pendingHalfPageFile, 0, height/2, width, height/2, padding);
                    }

                    if (mergedPdf.getPageCount() > 0) {
                        const pdfBytes = await mergedPdf.save();
                        downloadBlob(pdfBytes, `å‘ç¥¨æ‹¼ç‰ˆ_${formatDate(new Date())}.pdf`);
                    } else {
                        alert("æœªèƒ½ç”Ÿæˆä»»ä½•æœ‰æ•ˆé¡µé¢");
                    }
                } catch (e) {
                    alert('å¤„ç†å¤±è´¥ï¼š' + e.message);
                    console.error(e);
                } finally {
                    currentAction.value = 'idle';
                }
            };

            const drawCutLine = (page, width, height) => {
                const middleY = height / 2;
                page.drawLine({
                    start: { x: 20, y: middleY },
                    end: { x: width - 20, y: middleY },
                    thickness: 1,
                    color: grayscale(0.8),
                    dashArray: [5, 5],
                });
            };

            const embedAndDraw = async (targetDoc, targetPage, sourceFileObj, boxX, boxY, boxW, boxH, padding) => {
                try {
                    let drawableItem;
                    let srcDims;
                    let isRotated = false;

                    if (sourceFileObj.type === 'pdf') {
                        const srcDoc = await PDFDocument.load(sourceFileObj.arrayBuffer);
                        const [srcPage] = await targetDoc.embedPdf(srcDoc, [0]);
                        drawableItem = srcPage;
                        srcDims = srcPage.scale(1);
                    } else {
                        if (sourceFileObj.fileData.type === 'image/jpeg') {
                            drawableItem = await targetDoc.embedJpg(sourceFileObj.arrayBuffer);
                        } else {
                            drawableItem = await targetDoc.embedPng(sourceFileObj.arrayBuffer);
                        }
                        srcDims = drawableItem.scale(1);
                        if (sourceFileObj.isPortrait) isRotated = true;
                    }

                    const safeW = boxW - padding * 2;
                    const safeH = boxH - padding * 2;

                    let scale;
                    if (isRotated) {
                        scale = Math.min(safeW / srcDims.height, safeH / srcDims.width);
                    } else {
                        scale = Math.min(safeW / srcDims.width, safeH / srcDims.height);
                    }

                    const scaledW = srcDims.width * scale;
                    const scaledH = srcDims.height * scale;

                    const visualWidth = isRotated ? scaledH : scaledW;
                    const visualHeight = isRotated ? scaledW : scaledH;

                    const centerX = boxX + (boxW - visualWidth) / 2;
                    const centerY = boxY + (boxH - visualHeight) / 2;

                    if (isRotated) {
                        targetPage.drawImage(drawableItem, {
                            x: centerX,
                            y: centerY + visualHeight,
                            width: scaledW,
                            height: scaledH,
                            rotate: degrees(-90)
                        });
                    } else {
                        const drawOptions = { x: centerX, y: centerY, width: scaledW, height: scaledH };
                        if (sourceFileObj.type === 'pdf') targetPage.drawPage(drawableItem, drawOptions);
                        else targetPage.drawImage(drawableItem, drawOptions);
                    }
                    return true;
                } catch(e) {
                    console.error(`ç»˜åˆ¶æ–‡ä»¶ ${sourceFileObj.name} å¤±è´¥:`, e);
                    return false;
                }
            };

            const downloadBlob = (data, filename) => {
                const blob = new Blob([data], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                setTimeout(() => URL.revokeObjectURL(link.href), 1000);
            };

            const formatDate = (date) => {
                const pad = (n) => String(n).padStart(2, '0');
                const h = pad(date.getHours());
                const m = pad(date.getMinutes());
                return `${date.getFullYear()}${pad(date.getMonth() + 1)}${pad(date.getDate())}_${h}${m}`;
            };

            return {
                files, isDragging, currentAction, validFilesCount, btnText, fileInput,
                estimatedPages, paddingSetting,
                triggerFileInput, handleFileSelect, handleDrop, removeFile, clearAll, 
                processAndDownload, getFileIcon, moveFile, exportToTxt, renameAndZip
            };
        }
    }).mount('#app');
</script>
</body>
</html>
